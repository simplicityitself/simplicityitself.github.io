---
layout: article
author: Simplicity Itself Team
categories: Learning
title: Mastering Microservices – Adaptive Learning
---
Ever experienced that moment where your heart sinks at the words "We just want you to make this one, small and trivial change…".

If you build software, change is an inevitable force in your life and your ability to react to change can be the difference between a killer product and a last-to-the-post flop.

Given that change and speed of software evolution is so critical, why is it that so much software becomes a millstone around yourself and your team's next, leading to you dreading the next inevitable change that's needed? For over 10 years, focus has been consistently applied to helping us work in a more agile and adaptable fashion, with far less focus on how to create software that thrives in an agile environment.

This is not taught in an intensive style. Instead, it follows our <a title="Rationale for Adaptive Learning" href="/learning/rationale-for-work-based-learning/">Adaptive Learning</a> approach, spread over a more extended period of time. This permits the creation of positive feedback loops between the organisation, learners and trainers. This deepens and broadens the knowledge retained, and gives you better value for your money and an improved training result.

If you would like to discuss this course, or book it for your team, please <a href="/#contactus" target="_blank">contact us</a>

<h3>Audience</h3>
Any developer with some experience of networking, and wants to build software that adapts as fast as their business does.
<h4>In this course you will learn how to</h4>
<ul>
	<li>Understand Change: Manage evolution from a component, module and system perspective.</li>
	<li>Understand Complexity: Identify the causes of complexity in your architecture, design and code and the affect it has on dealing with change.</li>
	<li>Organise for Change: Organise your architecture, design and code for clarity and change.</li>
	<li>Clean Design and Architecture: Architect, design and build components that embrace change</li>
	<li>Reduce Inter and Intra System Coupling: Identify and Manage accidental coupling between components, modules and systems.</li>
	<li>Functional Programming for Humans: Apply practical functional programming concepts regardless of your language or framework choice.</li>
	<li>Apply Events: Apply Event-Driven Architectural patterns to increase de-coupling.</li>
	<li>Introduce new languages: When and How to apply the right language to simplify your code for a given component.</li>
</ul>
<h3>Programme</h3>
<h4>Topics</h4>
<ul>
	<li>Understanding Change
<ul>
	<li>Pushing the Elephant</li>
	<li>Real Agility requires Agile Software too.</li>
	<li>Maximising Human Comprehension</li>
	<li>Principle of Least Surprise</li>
	<li>Overproduction</li>
</ul>
</li>
	<li>Understanding Complexity
<ul>
	<li>A continuum</li>
	<li>Organise, Reduce, Encapsulate</li>
	<li>Doing the Simplest Thing</li>
</ul>
</li>
	<li>Adaptable Architecture
<ul>
	<li>Organising for Clarity and Change</li>
	<li>Clean Architecture</li>
	<li>The Hexagonal View of your Application</li>
	<li>The Life Preserver Pattern and Tool</li>
</ul>
</li>
	<li>Adaptable Design
<ul>
	<li>Designing Simple Components</li>
	<li>Reducing to the functionality that matters</li>
	<li>Organising, Reducing and Hiding Side-Effects</li>
	<li>Designing system, module and component APIs that embrace change</li>
	<li>Types of Coupling</li>
	<li>How and When to Overcome Coupling</li>
	<li>Interactions and Composition over Inheritance</li>
	<li>Polymorphism a la carte</li>
	<li>Characteristics of Supple Design</li>
	<li>Pipes, Filters and Events patterns</li>
</ul>
</li>
	<li>Adaptable Code - Functional Programming A La Carte, for Humans
<ul>
	<li>Components as Functions</li>
	<li>Maximising Unit Testing by Extracting Side Effects</li>
	<li>Reducing Ordering Complexity</li>
	<li>De-coupling through Events and CQRS</li>
	<li>Inspect what's happening at runtime with Complex Event Processing</li>
	<li>Implicit and Explicit data schema</li>
	<li>When and How to implement Postel's Law</li>
	<li>Why and How Monads help</li>
	<li>Working with data documents (Maps/Lists) with Combinator Functions</li>
	<li>Options and Protocols</li>
	<li>Factories and Avoiding Coupling through Construction and Configuration</li>
	<li>How to choose between implementation approaches: Libraries, Frameworks, Languages</li>
</ul>
</li>
</ul>
If you would like to discuss this course, or book it for your team, please <a href="/#contact" target="_blank">contact us</a>

&nbsp;