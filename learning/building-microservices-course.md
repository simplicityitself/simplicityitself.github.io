---
title: Building Microservices
layout: service
author: Simplicity Itself Team
categories: Learning
image: /images/vis/hex.png
redirect_from:
 - "/services/building-microservices.html"
---
Have you ever experienced that moment where your heart sinks at the words "We just want you to make this one, <b>small and trivial change…</b>".

If you build software, ***change is an inevitable force*** in your life and your ability to react to change can be the difference between a killer product and a last-to-the-post flop.

Given that change and speed of software evolution is so critical, why is it that so much software becomes a millstone around yourself and your team's next, leading to you dreading the next inevitable change that's needed? For over 10 years, focus has been consistently applied to helping us work in a more agile and adaptable fashion, with far less focus on how to create software that thrives in an agile environment.

This hands-on, extremely practical course teaches you the latest techniques you can apply today to your architecture, design and code to build software that doesn't fear change. This course will teach you how to build software that adapts as fast as your business and requirements do.

If you would like to discuss this course, or book it for your team, please <a href="/#contact" target="_blank">contact us</a>

<strong>Duration: 3 Days</strong>
<h3>Audience</h3>
Any developer with some experience of networking, and wants to build software that adapts as fast as their business does.
<h4>In this course you will learn how to</h4>
<ul>
	<li>Understand Change: Manage evolution from a component, module and system perspective.</li>
	<li>Understand Complexity: Identify the causes of complexity in your architecture, design and code and the affect it has on dealing with change.</li>
	<li>Organise for Change: Organise your architecture, design and code for clarity and change.</li>
	<li>Clean Design and Architecture: Architect, design and build components that embrace change</li>
	<li>Reduce Inter and Intra System Coupling: Identify and Manage accidental coupling between components, modules and systems.</li>
	<li>Functional Programming for Humans: Apply practical functional programming concepts regardless of your language or framework choice.</li>
	<li>Apply Events: Apply Event-Driven Architectural patterns to increase de-coupling.</li>
	<li>Introduce new languages: When and How to apply the right language to simplify your code for a given component.</li>
</ul>
<h3>Programme</h3>
<h4>Topics</h4>
<ul>
	<li>Understanding Change
<ul>
	<li>Pushing the Elephant</li>
	<li>Real Agility requires Agile Software too.</li>
	<li>Maximising Human Comprehension</li>
	<li>Principle of Least Surprise</li>
	<li>Overproduction</li>
</ul>
</li>
	<li>Understanding Complexity
<ul>
	<li>A continuum</li>
	<li>Organise, Reduce, Encapsulate</li>
	<li>Doing the Simplest Thing</li>
</ul>
</li>
	<li>Adaptable Architecture
<ul>
	<li>Organising for Clarity and Change</li>
	<li>Clean Architecture</li>
	<li>The Hexagonal View of your Application</li>
	<li>The Life Preserver Pattern and Tool</li>
</ul>
</li>
	<li>Adaptable Design
<ul>
	<li>Designing Simple Components</li>
	<li>Reducing to the functionality that matters</li>
	<li>Organising, Reducing and Hiding Side-Effects</li>
	<li>Designing system, module and component APIs that embrace change</li>
	<li>Types of Coupling</li>
	<li>How and When to Overcome Coupling</li>
	<li>Interactions and Composition over Inheritance</li>
	<li>Polymorphism a la carte</li>
	<li>Characteristics of Supple Design</li>
	<li>Pipes, Filters and Events patterns</li>
</ul>
</li>
	<li>Adaptable Code - Functional Programming A La Carte, for Humans
<ul>
	<li>Components as Functions</li>
	<li>Maximising Unit Testing by Extracting Side Effects</li>
	<li>Reducing Ordering Complexity</li>
	<li>De-coupling through Events and CQRS</li>
	<li>Inspect what's happening at runtime with Complex Event Processing</li>
	<li>Implicit and Explicit data schema</li>
	<li>When and How to implement Postel's Law</li>
	<li>Why and How Monads help</li>
	<li>Working with data documents (Maps/Lists) with Combinator Functions</li>
	<li>Options and Protocols</li>
	<li>Factories and Avoiding Coupling through Construction and Configuration</li>
	<li>How to choose between implementation approaches: Libraries, Frameworks, Languages</li>
</ul>
</li>
</ul>
&nbsp;

#### Day 1 - Architecture & Design for Simplicity and Antifragility:

* Introducing Antifragile Software and Simplicity
* Defining Microservices in term of their Principles, Benefits and Challenges
* Understand and explore the forces (stressors) of change on software
* Applying Simplicity, with O.R.E.
* Architecting and Designing for Software System Evolution with the Life Preserver tool
* Organising for concerns and simple components
* How to collaborate to discover change stressors on your software system
* Organising components for change

#### Day 2 - Implementing Antifragile Software with Simple Components, Events & Microservices

* Exploring and Managing change-stressor fault-lines between areas of your system
* Designing software bridges that handle change across fault-lines
* Applying de-coupling intelligently, balancing flexibility and complexity
* Applying Request-Response, Messaging and Events
* Designing when to apply and implement Postel’s Law

#### Day 3 - Deploying, Running, Testing & Managing Antifragile Software with Microservices

* Extracting components into Microservices
* Building, Deploying and Managing Effective Unix-style Microservice
* Pipelines
* Simplifying Microservice Management using Immutable Service Deployments
* Designing and Implementing Reactive Microservices
* Applying effective health and monitoring for microservices
* Designing and Implementing Microservice Failover and Auto-Recovery Strategies using the Circuit Breaker Pattern and Friends
* Designing and Implementing for Autonomy with Microservice ‘Cells'
* Enabling Governance and Innovation with Microservices
* Enabling Variation and Experimentation in Languages and Frameworks through Microservices
* Testing stressors for failure to avoid failure
* Testing and Continuous Delivery for Microservices 
* Containerisation and Docker
